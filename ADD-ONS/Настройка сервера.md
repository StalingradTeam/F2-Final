# Настройка сервера и деплой

Существует несколько способов подключения к серверу через "терминал". Мы можем использовать логин и пароль или публичный SSH-ключ для доступа к системе.
Мы будем использовать доступ по SSH-ключу, поэтому нам необходимо его сгенерировать.
Если у вас Linux/macOS или Windows 10 откройте терминал или командную строку (cmd/powershell) и выполните команду:

$ ssh-keygen -t rsa -b 2048

Заполнение полей не обязательно. Пропустить заполнение поля можно клавишей Enter.
После этого публичная часть ключа сохранится в файле по пути:

~/.ssh/id_rsa.pub - Linux/macOS;

C:\Users\<имя_пользователя>\.ssh\id_rsa.pub - Windows 10.

Если у вас Windows 7 или 8, вам необходимо скачать PuTTYGen. Генерация ключей с помощью PuTTY подробна описана в документации Яндекс.Облако.
После того как мы сгенерировали пару ssh ключей (закрытый и публичный), нам необходимо скопировать публичный ключ и вставить его в поле ssh-ключ.
 
Далее нажать "Создать ВМ".
Подключение к ВМ
После того как виртуальная машина получит статус "Running", мы можем подключиться к ней, используя имя пользователя (логин) на скриншоте выше и публичный ip-адрес, указанный в информации о ВМ:
 
Для пользователей Linux/macOS/Windows 10 подключение может быть выполнено с помощью утилиты ssh. В терминале (Linux/macOS) или cmd/powershell (Windows 10) необходимо набрать команду вида:

$ ssh <имя_пользователя>@<публичный_IP-адрес_виртуальной машины>

Например:

$ ssh user@84.144.50.30

И нажать Enter.

Далее, если вы подключаетесь первый раз, может появится предупреждение о неизвестном хосте. Введите в терминале слово yes и нажмите Enter.
Теперь мы имеем доступ к терминалу сервера и можем выполнять команды от пользователя user:

user@skillfactory:~$ _

Для пользователей Windows 7/8 подключение может быть осуществлено с помощью PuTTY. О том, как подключаться к серверу с помощью PuTTY, также рассказано в документации Яндекс.Облако, в разделе "Подключение к виртуальной машине".
Установка пакетов
 Добавить страницу в мои закладки
После того как мы создали виртуальную машину и подключились к ней, нам необходимо установить все сопутствующие пакеты программ, которые понадобятся для разворачивания django-проекта.
Nginx
Nginx - HTTP-сервер и прокси-сервер, который поможет нам раздавать статические файлы и проксировать запросы от пользователя к веб-серверу django.
Для того чтобы установить nginx, необходимо выполнить следующие команды:

$ sudo apt update

$ sudo apt install nginx

И подтвердить установку пакета.
sudo apt update - выполняет обновление дерева со списком пакетов, то есть актуализирует версии доступные для установки.
sudo apt install nginx - выполняет установку конкретного пакета nginx самой актуальной версии.
Синтаксис команды для установки пакета в целом выглядит так:

sudo apt install <название_пакета>

Указание версии пакета:

sudo apt install <название_пакета>=<версия_пакета>

Префикс sudo означает "выполнить команду с правами суперпользователя", некий аналог "выполнить от имени администратора" в Windows.
Данный префикс не нужен для команд, которые не требуют прав суперпользователя, например, для запуска скриптов, но нужен для установки системных пакетов и обновлений системы.
Также префикс можно опустить, если мы работаем под пользователем root, но данный подход следует избегать, так как это может навредить безопасности нашей системы.
Git
Для того чтобы организовать работу с репозиториями на нашем сервере, нам необходим git. Его установка выполняется командой:

$ sudo apt install git

После установки мы можем проверить версию клиента, для того чтобы убедится в том, что установка прошла успешно:

$ git --version

Python

В системе ubuntu уже предварительно установлен python версии 3.6.9.

Если мы хотим использовать более новую версию, то нам необходимо выполнить её установку. Например, версию 3.8.

$ sudo apt install python3.8

Так как версий python в ubuntu может быть установлено больше, чем одна, то использование конкретной версии указывается прямо в названии исполняемого интерпретатора, например: python3, python3.6, python3.8.
Посмотрим вывод от разных команд:

$ python3 --version

Python 3.6.9

$ python3.6 --version

Python 3.6.9

python3.8 --version

Python 3.8.0

Также нам необходимо установить менеджер python-пакетов pip:

$ sudo apt install python3-pip

Просмотр версии:

$ pip3 --version

pip 9.0.1 from /usr/lib/python3/dist-packages (python 3.6)

После установки pip нам необходимо установить библиотеки для работы с PostgreSQL:

$ sudo apt install libpq-dev python3.8-dev

$ python3.8 -m pip install psycopg2

## Настройка nginx

 Добавить страницу в мои закладки
Nginx в Ubuntu располагается по пути: /etc/nginx.

С помощью терминала перейдём в эту папку и посмотрим, что там находится:

$ cd /etc/nginx
/etc/nginx$ ls
conf.d          koi-utf     modules-available  proxy_params     sites-enabled  win-utf
fastcgi.conf    koi-win     modules-enabled    scgi_params      snippets
fastcgi_params  mime.types  nginx.conf         sites-available  uwsgi_params

Конфигурации для нашего будущего сайта будут храниться в папке sites-available. В папке sites-available хранятся конфигурации для всех доступных сайтов, а в папке sites-enabled хранятся ссылки на доступные сайты, которые доступны и включены в данный момент.
Создадим новую конфигурацию для нашего сайта и откроем её для редактирования:

$ sudo nano /etc/nginx/sites-available/skillfactory

В открывшемся окне добавим следующее содержание:

server {
    listen 80;
    server_name 84.44.123.95;

    location = /favicon.ico { access_log off; log_not_found off; }
}

В поле server_name необходимо указать публичный ip-адрес вашего сервера, который вы использовали при подключении к серверу.
В данном файле мы описали некий "сервер", который слушает 80-ый порт по адресу 84.44.123.95. Секция location указывает игнорировать все ошибки по пути /favicon.ico.

Далее нажимаем ctrl+o для записи, Enter и ctrl+x для выхода.
После создания файла skillfactory в папке sites-available нам необходимо добавить этот файл в папку sites-enabled. Но вместо того, чтобы копировать этот файл, мы просто добавим символическую ссылку на него (аналог ярлыка в Windows).
Для этого нужно выполнить команду ln -fs:

$ sudo ln -fs /etc/nginx/sites-available/skillfactory /etc/nginx/sites-enabled/

Где левым аргументом указывается название файла, на который мы ссылаемся, а правым — путь, по которому мы разместим эту ссылку.
Проверим:

$ cd /etc/nginx/sites-enabled/

$ ls -la

total 8
drwxr-xr-x 2 root root 4096 Feb 25 13:50 .
drwxr-xr-x 8 root root 4096 Feb 24 17:36 ..
lrwxrwxrwx 1 root root   34 Feb 24 17:36 default -> /etc/nginx/sites-available/default
lrwxrwxrwx 1 root root   39 Feb 25 13:50 skillfactory -> /etc/nginx/sites-available/skillfactory

Удалим ссылку на default и сам файл default, так как он нам не понадобится.

$ sudo rm -f /etc/nginx/sites-enabled/default

$ sudo rm -f /etc/nginx/sites-available/default

После всех манипуляций нам необходимо протестировать наши изменения на корректность, произвести тест конфига командой:

$ sudo nginx -t

Корректный вывод:

nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

Для того чтобы nginx перечитал конфигурацию, нам необходимо выполнить команду:

$ sudo nginx -s reload

Но иногда этого может не хватить, тогда мы можем перезапустить nginx полностью:

$ sudo service nginx restart

Но это обрывает все текущие соединения с клиентами, поэтому стоит использовать с осторожностью.
Теперь наш сервер раздаёт базовую страницу nginx по адресу, который мы указали в server_name:
ошибок с favicon не возникает

### Подключаем Django

 Добавить страницу в мои закладки
После того как мы установили все необходимые пакеты для нашего будущего приложения, пришла пора создать тестовое приложение. Попробуем запустить сервер на django и проксировать его через nginx.
Для начала установим библиотеку для работы с виртуальным окружением, для нашего python версии 3.8:

$ sudo apt install python3.8-venv

Перейдём в домашнюю директорию и создадим виртуальное окружение и установим django:

$ cd ~

$ mkdir venvs

$ cd venvs

$ python3.8 -m venv skillfactory_test

$ source skillfactory_test/bin/activate

(skillfactory_test) $ pip install django

Создадим проект:

(skillfactory_test) $ cd ~

(skillfactory_test) $ mkdir projects

(skillfactory_test) $ cd projects

(skillfactory_test) $ django-admin startproject 
test_skillfactory

Но перед тем как мы его запустим, отредактируем настройки nginx.
Откроем файл с настройками для редактирования:

(skillfactory_test) $ sudo nano /etc/nginx/sites-available/skillfactory

Допишем секцию location:

server {
    listen 80;
    server_name 84.44.123.95;

    location = /favicon.ico { access_log off; log_not_found off; }

    location / {
        proxy_pass http://127.0.0.1:8000;
    }
}

Сохраним командами ctrl+o, ctrl+x. Проверим конфигурацию и перечитаем конфиг nginx'ом:

(skillfactory_test) $ sudo nginx -t

(skillfactory_test) $ sudo service nginx restart

Осталось только запустить наш сервер:

(skillfactory_test) $ ./manage.py runserver

Теперь откроем наш сайт в браузере, по публичному ip-адресу:
Данную страницу мы видим по причине того, что наш сайт работает в режиме DEBUG=True. Данный режим крайне не рекомендуется для использования на публичном сервере.

Подправим настройки нашего проекта:

(skillfactory_test) $ nano test_skillfactory/settings.py 

Для того чтобы остановить сервер, нажмите ctrl+shift+c, или ctrl+c в зависимости от ОС, на которой вы работаете.

Подправим переменные в настройках на такие:

...
DEBUG = False

ALLOWED_HOSTS = ["127.0.0.1"]
...

Сохраним и перезапустим сервер:

(skillfactory_test) $ ./manage.py runserver

Откроем наш сайт в браузере:

К сожалению, если мы перейдём в админку, увидим печальную картину:

Никаких стилей и js-скриптов! И это после всего, что мы сделали!
Но это не проблема. Многие из вас уже сталкивались с проблемами статических файлов, когда использовали хероку. Сейчас мы с вами разберем подробнее то, как нам стоит работать со статическими файлами на примере админки.

Для начала откроем файл settings.py:

(skillfactory_test) $ nano test_skillfactory/settings.py 

Спустимся в самый конец файла и добавим следующие переменные:

 Добавить import os в верху до from settings import .. 

Переменная STATIC_ROOT отвечает за то, куда будет "сложена" статика после команды collectstatic.

Сохраним файл settings.py и выполним команду:

(skillfactory_test) $ ./manage.py collectstatic

Вывод:

130 static files copied to '/home/user/projects/test_skillfactory/static'.

Это означает, что все статические файлы были скопированы в папку, которую мы указали в переменной STATIC_ROOT.

Укажем путь до статических файлов в настройках nginx:

(skillfactory_test) $ sudo nano /etc/nginx/sites-available/skillfactory

Укажем новую секцию location, которая будет отвечать за статические файлы:

server {
    listen 80;
    server_name 84.44.123.95;

    location = /favicon.ico { access_log off; log_not_found off; }

    location / {
        proxy_pass http://127.0.0.1:8000;
    }

    location /static/ {
        root /home/user/projects/test_skillfactory;
    }
}

Сохраним наш файл и выйдем.

Проверяем конфиг и перезагружаем nginx командой sudo service nginx restart.
Теперь для того, чтобы понять, что здесь происходит, необходимо представить, как nginx обрабатывает наши запросы.
Допустим, мы делаем запрос на страницу по адресу 

http://84.44.123.95/admin.

 Так как nginx слушает наш ip-адрес, к которому мы обращаемся, он ищет подходящий location для всего, что стоит после него, то есть для /admin.
Так как у нас не указан location для /admin, он матчит его в общий location, то есть в location /.
После этого nginx пересылает (проксирует) наш запрос по адресу, который указан в location /, а именно по http://127.0.0.1:8000, при этом не забывая страницу нашего запроса, так что в конечном итоге выходит, что nginx проксирует запрос на http://127.0.0.1:8000/admin.
В этот момент его обрабатывает django и отдает веб-страницу вопрошающему, то есть nginx'у. А nginx проксирует этот ответ конечному пользователю.
В случае со статикой, нам необходимо особым образом перехватывать все запросы на /static. Но при этом nginx сам может отдавать статические файлы, если мы расскажем ему, где они лежат.

В секции location /static/ происходит следующее:

1.	Мы делаем запрос на http://84.44.123.95/static/admin/css/fonts.css

2.	Nginx отбрасывает http://84.44.123.95 оставляя только /static/admin/css/fonts.css

3.	location /static/ матчит наш запрос, так как в начале нашего запроса есть /static/

4.	root означает что перед /static/ необходимо подставить всё то, что мы прописали после, то есть /home/user/projects/test_skillfactory

5.	В конечном итоге соединяются пути из root /home/user/projects/test_skillfactory и из запроса /static/admin/css/fonts.css

6.	nginx ищет файл по пути: /home/user/projects/test_skillfactory/static/admin/css/fonts.css и находит.

Обратите внимание на слеши. Их не должно быть больше или меньше. Если мы не пишем конечный слеш в location, он должен быть прописан в root.
После всех манипуляций мы снова запускаем сервер и можем перейти по адресу http://84.44.123.95/admin, нажать сочетания клавиш ctrl+shift+r для того, чтобы сбросить кеш и насладиться великолепным оформлением django-админки.
Стоит добавить и то, что это далеко не все возможности веб-сервера nginx. Nginx является одним из популярнейших веб-серверов, и для его полного освоения могут понадобиться годы. Но в данном уроке мы лишь слегка задели его длинной палкой.

##### Добавляем базу данных

 Добавить страницу в мои закладки
Итак, мы с вами вплотную подошли к финишу. Осталось только подключить базу данных к нашему проекту. Для этого необходимо установить PostgreSQL.
Выполним установку PostgreSQL с помощью команды:

$ sudo apt install postgresql postgresql-contrib

Далее нам необходимо создать базу данных и пользователя postgres, для этого необходимо войти в консоль postgres и выполнить команды:

$ sudo -u postgres psql

$ CREATE DATABASE skillfactory_db;

$ CREATE USER skillfactory_user WITH PASSWORD 'skillfactory_password';

Далее необходимо дать все разрешения пользователю 

skillfactory_user для взаимодействия с базой skillfactory_db:

$ GRANT ALL PRIVILEGES ON DATABASE skillfactory_db TO skillfactory_user;

После этого мы можем выйти из интерактивной консоли postgres командой \q.

Если мы захотим склонировать проект из приватного репозитория, то вместо логина и пароля можно использовать публичный ssh-ключ.
Создадим такой ключ и добавим его в наш аккаунт на github:

$ ssh-keygen -t rsa -b 2048

$ cat ~/.ssh/id_rsa.pub

Скопируем ключ, который высветился в терминале и добавим его на github. Необходимо перейти по ссылке settings в правом верхнем углу:

Перейти на вкладку "SSH and GPG keys" и выбрать "New SSH key".

Вставим полученный на сервере публичный ssh-ключ:

И нажмём "Add SSH key". Теперь наш сервер может читать из закрытых репозиториев аккаунта.
После этого склонируем репозиторий в нашу папку projects:

$ cd ~/projects/

$ git clone git@github.com:mcridednb/skillfactory.git
$ cd skillfactory/

Данный репозиторий публичный, поэтому вы тоже можете склонировать его к себе на сервер.

Настроим виртуальное окружение и добавим файл с настройками проекта:

$ cd ~/.venvs

$ python3.8 -m venv .venv

$ source .venv/bin/activate

$ cd -

$ nano .env

В открывшемся окне пропишем секретный ключ и наши настройки для БД, так как они не должны и не хранятся в репозитории.

SECRET_KEY='_7w@!!20yuqh^97d+f)rhj-#7uz99qjrx!4op6)!k$r!h-@krm'

DB_NAME='skillfactory_db'

DB_USER='skillfactory_user'

DB_PASSWORD='skillfactory_password'

DB_HOST=127.0.0.1

DB_PORT=5432

Сохраним и выйдем. Данный файл необходим для заполнения данными файла settings.py, а именно части с настройками БД, которая выглядит вот так:
...
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': os.getenv("DB_NAME"),
        'USER': os.getenv("DB_USER"),
        'PASSWORD': os.getenv("DB_PASSWORD"),
        'HOST': os.getenv("DB_HOST", "127.0.0.1"),
        'PORT': os.getenv("DB_PORT", 5432),
    }
}
...

Всё, что указано в файле .env, автоматически подставится в секцию DATABASES при запуске django-приложения.
Более подробно об использовании библиотеки можно узнать здесь.
После установим зависимости из файла requirements.txt:

$ pip install -r requirements.txt

Выполним миграции, создадим суперпользователя и запустим наш проект:

$ ./manage.py migrate

$ ./manage.py createsuperuser

Перейдём по нашему ip-адресу в админку нашего проекта:
Таким образом мы настроили PostgreSQL для нашего проекта.
Обратите внимание на использование библиотеки python-dotenv и её имплементации в файле settings.py, в разделе с настройками базы данных. Такой подход позволяет не хранить секретные данные даже в закрытом репозитории, а заполнение данных происходит на уровне сервера, в .env файле, который, кстати, добавлен в .gitignore.

стоит упомянуть о консольной утилите, которая позволяет упростить взаимодействие с сервером.
Эта консольная утилита называется "tmux", установим её на сервере с помощью команды:

$ sudo apt install tmux 

Команда tmux new откроет новую сессию tmux на сервере.

$ tmux new 

Для создания нового окна tmux, нажмите ctrl+b затем c. В нижней части терминала отображаются все текущие открытые сессии.
Переключиться между сессиями можно командой: ctrl+b, затем выбрать номер открытой сессии (0..9). Разделить текущее окно можно командой: ctrl+b и %. Выйти из текущей сессии можно командой ctrl+b и d, а подключится обратно командой tmux attach.
Краткую шпаргалку можно посмотреть тут.
Кстати, для того, чтобы Django не останавливалась после запуска сервера, после закрытия терминала, необходимо запустить сервер через tmux, нажать ctrl+b и d и после можно закрывать соединение с сервером, django не перестанет работать после закрытия терминала. То есть мы запустим ./manage.py runserver внутри tmux, а после просто отключимся от tmux, при этом ./manage.py runserver продолжит работу.
